source db_slave
{
        type                    = mysql
        sql_host                = 192.168.77.51 #read
        sql_user                = geograph
        sql_pass                = ***********
        sql_db                  = geograph_live
        sql_port                = 3306
}
source db_master : db_slave
{
        sql_host                = 192.168.77.50 #master
}



#############################################################################
# GAZETTEER
##########

source srcgaz2 : db_slave
{
        sql_query               = \
                SELECT id, name,gr,localities,grs,score, \
                CONCAT(SUBSTRING(gr,1,LENGTH(gr)-3),SUBSTRING(gr,LENGTH(gr)-1,1)) AS hectad \
                FROM placename_index
        sql_attr_uint           = score
        sql_query_info          = SELECT name FROM placename_index WHERE id=$id
}

index gaz2
{
        source                  = srcgaz2
        path                    = /var/sphinx/gaz2
        docinfo                 = extern
        morphology              = none
        stopwords               =
        min_word_len            = 1
        charset_type            = sbcs

#	enable_star             = 1
        min_prefix_len          = 1
        prefix_fields           = name, localities
        min_infix_len           = 0
}
source srcgaz : db_slave
{
        sql_query               = \
                SELECT id, name,gr,localities,grs,score, \
                CONCAT(SUBSTRING(gr,1,LENGTH(gr)-3),SUBSTRING(gr,LENGTH(gr)-1,1)) AS hectad \
                FROM placename_index
        sql_attr_uint           = score
        sql_query_info          = SELECT name FROM placename_index WHERE id=$id
}

index gaz
{
        source                  = srcgaz
        path                    = /var/sphinx/gaz
        docinfo                 = extern
        morphology              = none
        stopwords               =
        min_word_len            = 1
        charset_type            = sbcs

#	enable_star             = 1
        min_prefix_len          = 1
        prefix_fields           = name, localities
        min_infix_len           = 0
}

index gaz_stopped : gaz
{
	path                    = /var/sphinx/gaz_stopped
	stopwords               = /var/sphinx/gaz_stopwords.txt	
}
#built with "indexer gaz --buildstops gaz_stopwords.txt 1000"



index gaz_stemmed : gaz
{
        path                    = /var/sphinx/gaz_stemmed
        morphology              = stem_en
	enable_star             = 1
        index_exact_words       = 1
        min_prefix_len          = 10
}

index gaz_meta : gaz
{
        path                    = /var/sphinx/gaz_meta
	morphology              = metaphone
 enable_star             = 1
	min_prefix_len          = 10
}



#############################################################################
# Groups
##########

source srcgroup : db_slave
{
        sql_query               = \
                SELECT gridimage_group_stat_id,label,images \
                FROM gridimage_group_stat 
        sql_query_info          = SELECT * FROM gridimage_group_stat WHERE gridimage_group_stat_id=$id
	sql_attr_uint           = images
}

index group
{
        source                  = srcgroup
        path                    = /var/sphinx/group
        docinfo                 = extern
        morphology              = none
        stopwords               =
        min_word_len            = 1
        charset_type            = sbcs

        min_prefix_len          = 2
        min_infix_len           = 0
}



#############################################################################
# USERS
##########

source srcuser : db_slave
{
        sql_query               = \
                SELECT user_id, nickname, realname \
                FROM user \
		INNER JOIN user_stat USING (user_id) \
		WHERE rights LIKE '%basic%'
        sql_query_info          = SELECT user_id, nickname, realname FROM user WHERE user_id=$id
}

index user
{
        source                  = srcuser
        path                    = /var/sphinx/user
        docinfo                 = extern
        morphology              = none
        stopwords               =
        min_word_len            = 1
        charset_type            = sbcs

        min_prefix_len          = 2
        min_infix_len           = 0
}

#############################################################################
# TagSoup
##########

source srctagsoup : db_slave
{
        sql_query               = \
SELECT gridimage_id, title, comment, GROUP_CONCAT(tag SEPARATOR '?') AS tags, \
 CONCAT(SUBSTRING(grid_reference,1,LENGTH(grid_reference)-3),SUBSTRING(grid_reference,LENGTH(grid_reference)-1,1)) AS hectad, grid_reference, \
 gi.user_id, GROUP_CONCAT(tag_id) AS all_tag_id, GROUP_CONCAT(IF(prefix!='top',tag_id,NULL)) AS tag_id, \
 RADIANS(gi.wgs84_lat) AS wgs84_lat,RADIANS(gi.wgs84_long) AS wgs84_long \
FROM gridimage_search gi INNER JOIN tag_public USING (gridimage_id) \
GROUP BY gridimage_id \
HAVING tag_id IS NOT NULL \
ORDER BY NULL 
        sql_attr_uint           = user_id
	sql_attr_multi		= uint all_tag_id from field
	sql_attr_multi		= uint tag_id from field
        sql_attr_float          = wgs84_lat
        sql_attr_float          = wgs84_long
        sql_query_info          = SELECT title,grid_reference,realname FROM gridimage_search WHERE gridimage_id=$id
}

index tagsoup
{
        source                  = srctagsoup
        path                    = /var/sphinx/tagsoup
        docinfo                 = extern
        morphology              = none
        min_word_len            = 1
        charset_type            = sbcs
        stopwords               = /var/sphinx/tagstops.txt
}


#############################################################################
# Tags
##########

source srctags : db_slave
{
        sql_query               = \
                SELECT tag_id,prefix,tag,COUNT(*) AS images, '_all_' as a, \
			GROUP_CONCAT(DISTINCT user_id) AS user_id, \
                	IF(canonical = 0 OR canonical IS NULL,tag_id,canonical) AS grouping, \
                	IF(canonical = 0 OR canonical IS NULL,1,0) AS prefered \
                FROM tag_public \
                GROUP BY tag_id \
                ORDER BY null
        sql_attr_uint           = images
	sql_attr_multi		= uint user_id from field;
	sql_attr_uint           = grouping
	sql_attr_bool           = prefered
	sql_field_string	= tag

        sql_query_info          = SELECT * FROM tag WHERE tag_id=$id
}

index tags
{
        source                  = srctags
        path                    = /var/sphinx/tags
        docinfo                 = extern
        morphology              = none
        stopwords               =
        min_word_len            = 1
        charset_type            = sbcs

        min_prefix_len          = 2
        min_infix_len           = 0
}



source srctags2 : db_slave
{
        sql_query               = \
                SELECT tag_id,prefix,tag,COUNT(*) AS images \
                FROM tag_public \
                GROUP BY tag_id \
                ORDER BY null
        sql_attr_uint           = images
	sql_field_string	= prefix
	sql_field_string	= tag
}


index tags2
{
        source                  = srctags2
        path                    = /var/sphinx/tags2
        docinfo                 = extern
        morphology              = none
        stopwords               =
        min_word_len            = 1
        charset_type            = sbcs

        min_prefix_len          = 2
        min_infix_len           = 0
	enable_star = 1
	expand_keywords	= 1
}



#############################################################################
# Gridimage-Tag
##########

source srcgridimagetags : db_slave
{
	sql_query_pre 		= SET SESSION group_concat_max_len = 100000
        sql_query               = \
                SELECT tag_id,gridimage_id,prefix,tag, \
			CONCAT(SUBSTRING(grid_reference,1,LENGTH(grid_reference)-3),SUBSTRING(grid_reference,LENGTH(grid_reference)-1,1)) AS hectad, grid_reference, \
	                RADIANS(wgs84_lat) AS wgs84_lat,RADIANS(wgs84_long) AS wgs84_long, \
                        IF(canonical = 0 OR canonical IS NULL,tag_id,canonical) AS grouping, \
                        IF(canonical = 0 OR canonical IS NULL,1,0) AS prefered \
                FROM tag_public \
			INNER JOIN gridimage_search USING (gridimage_id)
        sql_attr_float          = wgs84_lat
        sql_attr_float          = wgs84_long

        sql_attr_uint           = gridimage_id
        sql_attr_uint           = grouping
        sql_attr_bool           = prefered

        sql_query_info          = SELECT * FROM tag WHERE tag_id=$id
}

index gridimagetags
{
        source                  = srcgridimagetags
        path                    = /var/sphinx/gridimagetags
        docinfo                 = extern
        morphology              = none
        stopwords               =
        min_word_len            = 1
        charset_type            = sbcs

        min_prefix_len          = 2
        min_infix_len           = 0
}


#############################################################################
# CATEGORY
##########

source srccategory : db_slave
{
        sql_query               = \
                SELECT category_id, imageclass, c \
                FROM category_stat
	sql_attr_uint		= c
        sql_query_info          = SELECT imageclass FROM category_stat WHERE category_id=$id
}

index category
{
        source                  = srccategory
        path                    = /var/sphinx/category
        docinfo                 = extern
        morphology              = none
        stopwords               =
        min_word_len            = 1
        charset_type            = sbcs

        min_prefix_len          = 2
        min_infix_len           = 0
}


source srccategory2 : db_slave
{
	sql_query_pre 		= SET SESSION group_concat_max_len = 100000
        sql_query               = \
                SELECT CRC32(LOWER(imageclass)) AS id,imageclass,COUNT(*) AS images, \
                        GROUP_CONCAT(DISTINCT user_id) AS user_id \
                FROM gridimage_search \
		WHERE imageclass != '' \
                GROUP BY imageclass \
                ORDER BY null
        sql_attr_uint           = images
        sql_attr_multi          = uint user_id from field;
        sql_field_string        = imageclass

        sql_query_info          = SELECT imageclass FROM category_stat WHERE category_id=$id
}

index category2
{
        source                  = srccategory2
        path                    = /var/sphinx/category2
        docinfo                 = extern
        morphology              = none
        stopwords               =
        min_word_len            = 1
        charset_type            = sbcs

        min_prefix_len          = 2
        min_infix_len           = 0
}

#############################################################################
# IMAGES GROUPED BY SWARM
##########

source srcswarm : db_master
{
	sql_query = SELECT swarm_id,s.title,s.grid_reference,images, \
		GROUP_CONCAT(g.title) AS titles, GROUP_CONCAT(comment) AS comments,GROUP_CONCAT(tags) AS tags, \
		GROUP_CONCAT(gridimage_id) AS gids \
		FROM swarm s \
			INNER JOIN gridimage_swarm USING (swarm_id) \
			INNER JOIN gridimage_search g USING (gridimage_id) \
		GROUP BY swarm_id ORDER BY NULL
	sql_attr_uint = images
        sql_attr_multi          = uint gids from field
}
index swarm
{
        source                  = srcswarm
        path                    = /var/sphinx/swarm
        docinfo                 = extern
        morphology              = stem_en
        min_word_len            = 1
        charset_type            = sbcs
}


#############################################################################
# IMAGES GROUPED BY SQUARE
##########

source srcsqim : db_slave
{
        sql_query_range         = SELECT min(gridsquare_id),max(gridsquare_id) FROM gridsquare
        sql_query_pre           = SET group_concat_max_len = 30000
        sql_query               = \
                SELECT gi.gridsquare_id, grid_reference, GROUP_CONCAT(title) AS title, \
		GROUP_CONCAT(comment) AS comment, CONCAT('ftf',MAX(ftf)) AS ftf, \
		GROUP_CONCAT(DISTINCT imageclass) AS imageclass, \
		LEFT(RIGHT(grid_reference,4),2) AS easting, RIGHT(grid_reference,2) AS northing, \
		SUBSTRING(grid_reference,1,LENGTH(grid_reference)-4) AS myriad, \
                CONCAT(SUBSTRING(grid_reference,1,LENGTH(grid_reference)-3),SUBSTRING(grid_reference,LENGTH(grid_reference)-1,1)) AS hectad, \
		CONCAT('land',IF(percent_land=0,0,(percent_land DIV 20)+1)) AS land, \
                GROUP_CONCAT(DISTINCT name) AS place, \
                GROUP_CONCAT(DISTINCT localities) AS locality \
                FROM gridimage gi \
		INNER JOIN gridsquare gs USING (gridsquare_id) \
		LEFT JOIN placename_index p ON (gs.grid_reference = p.gr) \
		WHERE moderation_status IN ('geograph','accepted') \
		AND gi.gridsquare_id>=$start AND gi.gridsquare_id<=$end \
		GROUP BY gi.gridsquare_id
        sql_query_info          = SELECT gridsquare_id,grid_reference FROM gridsquare WHERE gridsquare_id=$id
}
#select grid_reference,gr,name from gridsquare inner join placename_index on (placename_id = id) limit 10;
index sqim
{
        source                  = srcsqim
        path                    = /var/sphinx/sqim
        docinfo                 = extern
        morphology              = none
        stopwords               =
        min_word_len            = 2
        charset_type            = sbcs

        min_prefix_len          = 0
        min_infix_len           = 0
}



#############################################################################
# DISCUSSION
##########

source post : db_master
{
	sql_query_pre           = REPLACE INTO sph_counter SELECT 'geobb_posts', MAX(post_id),2 as server_id FROM geobb_posts
        sql_query               = \
                SELECT p.post_id, UNIX_TIMESTAMP(post_time) AS post_time, t.forum_id as forum, p.topic_id,\
                        topic_title as title, post_text as text, poster_name as name, \
			IF(p.forum_id = 5,SUBSTRING(topic_title,1,LENGTH(topic_title)-4),'') AS myriad, \
                	IF(p.forum_id = 5,CONCAT(SUBSTRING(topic_title,1,LENGTH(topic_title)-3),SUBSTRING(topic_title,LENGTH(topic_title)-1,1)),'') AS hectad, \
                        REPLACE(post_time,'-','') AS day, REPLACE(substring(post_time,1,7),'-','') AS month, substring(post_time,1,4) AS year \
                FROM geobb_posts p \
                INNER JOIN geobb_topics t using (topic_id) \
                WHERE p.post_id<=( SELECT max_doc_id FROM sph_counter WHERE counter_id='geobb_posts' and server_id=2)

        sql_attr_timestamp      = post_time
#	sql_attr_uint           = forum
	sql_attr_uint           = topic_id
        sql_query_info          = SELECT * FROM geobb_posts WHERE post_id=$id
}
source post_delta : post
{
        sql_query_pre           = 
        sql_query               = \
                SELECT p.post_id, UNIX_TIMESTAMP(post_time) AS post_time, t.forum_id as forum, p.topic_id,\
                        topic_title as title, post_text as text, poster_name as name, \
                        REPLACE(post_time,'-','') AS day, REPLACE(substring(post_time,1,7),'-','') AS month, substring(post_time,1,4) AS year \
                        FROM geobb_posts p \
                INNER JOIN geobb_topics t using (topic_id) \
                WHERE p.post_id>( SELECT max_doc_id FROM sph_counter WHERE counter_id='geobb_posts' and server_id=2)
}

#################

index post
{
        source                  = post
        path                    = /var/sphinx/post
        docinfo                 = extern
        morphology              = none
        stopwords               =
        min_word_len            = 1
        charset_type            = sbcs

        min_prefix_len          = 0
        min_infix_len           = 0
}
index post_delta : post
{
        source                  = post_delta
        path                    = /var/sphinx/post_delta
}

index post_stemmed : post
{
        source                  = post
        path                    = /var/sphinx/post_stemmed
        morphology              = stem_en
	index_exact_words       = 1
	wordforms 		= /var/sphinx/wordforms.txt
}
index post_stemmed_delta : post_delta
{
        source                  = post_delta
        path                    = /var/sphinx/post_stemmed_delta
        morphology              = stem_en
	index_exact_words	= 1
	wordforms 		= /var/sphinx/wordforms.txt
}
#############################################################################
# SNIPPETS
##########

source snippet : db_slave
{
        sql_query               = \
                SELECT snippet_id,if(s.title='','none',s.title) as title,if(s.comment='','none',s.comment) as comment,if(s.grid_reference='','none',s.grid_reference) as grid_reference, \
		CRC32(LOWER(s.title)) AS titlecrc, \
		s.user_id,u.realname,GROUP_CONCAT(gs.gridimage_id) AS gridimage_id, snippet_id AS id, \
		GROUP_CONCAT(gi.grid_reference) AS image_square, COUNT(distinct gs.gridimage_id) AS images, \
		SUBSTRING(s.grid_reference,1,LENGTH(s.grid_reference)-4) AS myriad, \
                CONCAT(SUBSTRING(s.grid_reference,1,LENGTH(s.grid_reference)-3),SUBSTRING(s.grid_reference,LENGTH(s.grid_reference)-1,1)) AS hectad, \
                RADIANS(s.wgs84_lat) AS wgs84_lat,RADIANS(s.wgs84_long) AS wgs84_long \
                FROM snippet s \
                        LEFT JOIN gridimage_snippet gs USING (snippet_id) \
			LEFT JOIN user u ON (s.user_id = u.user_id) \
			LEFT JOIN gridimage_search gi ON (gs.gridimage_id = gi.gridimage_id) \
                WHERE enabled = 1 \
                GROUP BY snippet_id ORDER BY null

        sql_attr_uint           = user_id
        sql_attr_uint           = titlecrc
        sql_attr_uint           = images
        sql_attr_float          = wgs84_lat
        sql_attr_float          = wgs84_long
        sql_query_info          = SELECT snippet_id,title,grid_reference,user_id FROM snippet WHERE snippet_id=$id
}

index snippet
{
        source                  = snippet
        path                    = /var/sphinx/snippet
        docinfo                 = extern
        morphology              = stem_en
        index_exact_words         = 1
        min_word_len            = 1
        charset_type            = sbcs
        min_prefix_len          = 0
        min_infix_len           = 0
}

#############################################################################
# DOCUMENTS
##########

source document : db_slave
{
        sql_query               = \
                SELECT content.content_id,title,extract,words,realname,UNIX_TIMESTAMP(created) AS created,UNIX_TIMESTAMP(content.updated) AS updated, \
                        source,content.source+0 AS asource \
                FROM content \
                        LEFT JOIN user USING (user_id) \
		WHERE \
			type = 'document'

        sql_attr_timestamp      = updated
        sql_attr_timestamp      = created
        sql_attr_uint           = asource
        sql_query_info          = SELECT content_id,title,extract,type,url FROM content WHERE content_id=$id
}

index document_stemmed
{
        source                  = document
        path                    = /var/sphinx/document_stemmed
        docinfo                 = extern
        morphology              = stem_en
        stopwords               =
        min_word_len            = 1
        charset_type            = sbcs
        index_exact_words       = 1
        min_prefix_len          = 0
        min_infix_len           = 0
	wordforms 		= /var/sphinx/wordforms.txt
}

source document_words : db_slave
{
        sql_query               = \
                SELECT id,word,uses,stemcrc FROM document_words
	sql_attr_uint		= uses
	sql_attr_uint		= stemcrc
	sql_query_info          = SELECT id,word,uses FROM content WHERE id=$id
}

index document_words
{
        source                  = document_words
        path                    = /var/sphinx/document_words
        docinfo                 = extern
        min_word_len            = 1
        charset_type            = sbcs
        min_prefix_len          = 1
        min_infix_len           = 0
}

#############################################################################
# CONTENT
##########

source content : db_slave
{
	sql_query		= \
		SELECT content.content_id,title,extract,words,realname,UNIX_TIMESTAMP(created) AS created,UNIX_TIMESTAMP(content.updated) AS updated,content.source,type, \
			content.source+0 AS asource,content.gridimage_id,content.gridsquare_id, \
			coalesce(gs.grid_reference,'none') as grid_reference, squares, content.images as aimages, \
			SUBSTRING(gs.grid_reference,1,LENGTH(gs.grid_reference)-4) AS myriad, \
			CONCAT(SUBSTRING(gs.grid_reference,1,LENGTH(gs.grid_reference)-3),SUBSTRING(gs.grid_reference,LENGTH(gs.grid_reference)-1,1)) AS hectad \
		FROM content \
			LEFT JOIN user USING (user_id) \
			LEFT JOIN gridsquare gs ON (content.gridsquare_id = gs.gridsquare_id) \
			LEFT JOIN content_gridsquare cg ON(content.content_id = cg.content_id)

	sql_attr_timestamp	= updated
	sql_attr_timestamp	= created
        sql_attr_uint           = asource
	sql_attr_uint           = aimages
        sql_attr_uint           = gridimage_id
        sql_attr_uint           = gridsquare_id
	sql_query_info		= SELECT content_id,title,extract,type,url FROM content WHERE content_id=$id
}

index content_stemmed
{
	source			= content
	path			= /var/sphinx/content_stemmed
	docinfo			= extern
	morphology		= stem_en
	stopwords		=
	min_word_len		= 1
	charset_type		= sbcs
        index_exact_words       = 1
	min_prefix_len		= 0
	min_infix_len		= 0
	wordforms 		= /var/sphinx/wordforms.txt
}

index content
{
        source                  = content
        path                    = /var/sphinx/content
        docinfo                 = extern
        morphology              = none
        stopwords               =
        min_word_len            = 1
        charset_type            = sbcs

        min_prefix_len          = 0
        min_infix_len           = 0
}


#############################################################################
# TICKETS
##########

source tickets : db_slave
{
        sql_query               = \
                SELECT t.gridimage_ticket_id, t.status, UNIX_TIMESTAMP(suggested) AS suggested, \
                gi.title, gi.comment, gi.imageclass, gi.realname, gi.grid_reference, \
                SUBSTRING(gi.grid_reference,1,LENGTH(gi.grid_reference)-4) AS myriad, \
                CONCAT(SUBSTRING(gi.grid_reference,1,LENGTH(gi.grid_reference)-3),SUBSTRING(gi.grid_reference,LENGTH(gi.grid_reference)-1,1)) AS hectad, \
                notes, s.realname AS suggester \
                FROM gridimage_ticket t \
                        INNER JOIN gridimage_search gi ON (gi.gridimage_id = t.gridimage_id) \
                        INNER JOIN user AS s ON (s.user_id = t.user_id) \
                WHERE t.status IN ('pending','open')
        sql_attr_timestamp      = suggested
        sql_query_info          = SELECT * FROM gridimage_ticket WHERE gridimage_ticket_id=$id
}
                
index tickets
{
        source                  = tickets
        path                    = /var/sphinx/tickets
        docinfo                 = extern
        morphology              = none
        stopwords               =
        min_word_len            = 1
        charset_type            = sbcs

        min_prefix_len          = 0
        min_infix_len           = 0
}

#############################################################################
# IMAGES
##########

source gridimage : db_master
{
        sql_query_pre           = REPLACE INTO sph_counter SELECT 'gridimage_search', MAX(gridimage_id)-1500,2 as server_id FROM gridimage_search

        sql_query_pre           = DROP TABLE IF EXISTS geograph_tmp.gridimage_snippet_text
        sql_query_pre           = \
		CREATE TABLE geograph_tmp.gridimage_snippet_text \
		SELECT gridimage_id, GROUP_CONCAT(gs.snippet_id) AS snippet_id, GROUP_CONCAT(s.comment) AS snippet, GROUP_CONCAT(s.title) AS snippet_title \
		FROM gridimage_snippet gs \
		LEFT JOIN snippet s USING (snippet_id) \
		WHERE gridimage_id < 4294967296 AND enabled = 1 \
		GROUP BY gridimage_id
	sql_query_pre           = ALTER TABLE geograph_tmp.gridimage_snippet_text ADD PRIMARY KEY (gridimage_id)

        sql_query_pre           = create temporary table tagtest (gridimage_id int unsigned primary key,newtags text) select gridimage_id,group_concat(if(prefix!='',concat(prefix,':',tag),tag) order by prefix = 'top' desc,tag SEPARATOR '?') as newtags from gridimage_tag gt inner join tag t using (tag_id) where gt.status = 2 and t.status = 1 and gridimage_id < 4294967296 group by gridimage_id order by null
        sql_query_pre           = update gridimage_search,tagtest set tags = newtags, upd_timestamp = upd_timestamp where gridimage_search.gridimage_id = tagtest.gridimage_id

        sql_query_range         = SELECT 1, max_doc_id FROM sph_counter WHERE counter_id='gridimage_search' and server_id=2
        sql_range_step          = 50000

        sql_query               = \
                SELECT gi.gridimage_id, UNIX_TIMESTAMP(gi.submitted) AS submitted, TO_DAYS(REPLACE(gi.imagetaken,'-00','-01')) AS takendays, gi.user_id, \
                gi.title, gi.comment, gi.imageclass, gi.realname, gi.grid_reference, \
                snippet_id, snippet, snippet_title, IF(tags!='',CONCAT('__TAG__ ',REPLACE(tags,'?',' __TAG__ '),' __TAG__'),'null') AS tags, \
                SUBSTRING(gi.grid_reference,1,LENGTH(gi.grid_reference)-4) AS myriad, \
                CONCAT(SUBSTRING(gi.grid_reference,1,LENGTH(gi.grid_reference)-3),SUBSTRING(gi.grid_reference,LENGTH(gi.grid_reference)-1,1)) AS hectad, \
                REPLACE(gi.imagetaken,'-','') AS takenday, REPLACE(substring(gi.imagetaken,1,7),'-','') AS takenmonth, substring(gi.imagetaken,1,4) AS takenyear, \
		MONTHNAME(gi.imagetaken) AS month, substring(gi.imagetaken,1,4) AS atakenyear, \
                RADIANS(gi.wgs84_lat) AS wgs84_lat,RADIANS(gi.wgs84_long) AS wgs84_long, \
                IF(gi.moderation_status='accepted','supplemental',gi.moderation_status) AS status, gi.ftf, gi.points, \
                CRC32(LOWER(gi.imageclass)) AS classcrc, LENGTH(gi.comment) AS clen, \
                (gi.reference_index * 10000000 + (viewpoint_northings DIV 1000) * 1000 + viewpoint_eastings DIV 1000) AS viewsquare, \
                gi.user_id AS auser_id, \
		coalesce(sequence,gi.gridimage_id+4000000) AS sequence, \
		UNIX_TIMESTAMP(REPLACE(gi.imagetaken,'-00','-01')) AS aimagetaken, \
		IF(gi.moderation_status = 'accepted' AND g2.nateastings>0 AND viewpoint_eastings>0 AND (g2.nateastings DIV 1000 != viewpoint_eastings DIV 1000 OR g2.natnorthings DIV 1000 != viewpoint_northings DIV 1000),'crossgrid','') AS grid, \
                conv(gi.grid_reference,36,10) as agridsquare, \
                conv(SUBSTRING(gi.grid_reference,1,LENGTH(gi.grid_reference)-4),36,10) AS amyriad, \
                conv(CONCAT(SUBSTRING(gi.grid_reference,1,LENGTH(gi.grid_reference)-3),SUBSTRING(gi.grid_reference,LENGTH(gi.grid_reference)-1,1)),36,10) AS ahectad, \
                (gi.reference_index * 10000000 + IF(g2.natgrlen+0 <= 3,((g2.nateastings DIV 100) mod 100) * 100 + ((g2.natnorthings DIV 100) mod 100),0)) AS scenti \
                FROM gridimage_search gi\
                        INNER JOIN gridimage g2 USING (gridimage_id) \
                        LEFT JOIN geograph_tmp.gridimage_snippet_text gs USING (gridimage_id) \
			LEFT JOIN gridimage_sequence s ON (s.gridimage_id = gi.gridimage_id) \
                WHERE gi.gridimage_id>=$start AND gi.gridimage_id<=$end 

	sql_query_post 		= DROP TABLE IF EXISTS geograph_tmp.gridimage_snippet_text

        sql_attr_timestamp      = submitted
        sql_attr_timestamp      = aimagetaken
#       sql_group_column        = viewsquare  #we do this a fulltext filter now
        sql_attr_uint           = takendays
        sql_attr_uint           = atakenyear
	sql_attr_uint           = classcrc
        sql_attr_uint           = clen
        sql_attr_uint           = auser_id
        sql_attr_uint           = sequence
        sql_attr_bigint         = agridsquare
        sql_attr_uint           = amyriad
        sql_attr_uint           = ahectad
        sql_attr_uint           = scenti
        sql_attr_float          = wgs84_lat
        sql_attr_float          = wgs84_long
	sql_attr_multi		= uint bucket_id from query; SELECT gridimage_id,tag_id FROM tag INNER JOIN gridimage_tag USING (tag_id) WHERE prefix = 'bucket'
        sql_query_info          = SELECT title,realname FROM gridimage_search WHERE gridimage_id=$id
}

source gi_delta : gridimage
{
        sql_query_pre           = 

        sql_query_pre           = DROP TABLE IF EXISTS sph_delta_ids
	sql_query_pre           = CREATE TABLE sph_delta_ids (primary key (`gridimage_id`)) \
		SELECT gridimage_id FROM gridimage_search WHERE gridimage_id > (SELECT max_doc_id FROM sph_counter WHERE counter_id='gridimage_search' and server_id=2) \
		OR upd_timestamp > date_sub(now(),interval 4 day)

        sql_query_pre           = DROP TABLE IF EXISTS geograph_tmp.gridimage_snippet_text_delta
        sql_query_pre           = CREATE TABLE geograph_tmp.gridimage_snippet_text_delta (primary key (`gridimage_id`)) \
		SELECT gridimage_id, GROUP_CONCAT(gs.snippet_id) AS snippet_id, GROUP_CONCAT(s.comment) AS snippet, GROUP_CONCAT(s.title) AS snippet_title \
		FROM gridimage_snippet gs \
		INNER JOIN sph_delta_ids USING (gridimage_id) \
		LEFT JOIN snippet s USING (snippet_id) \
		WHERE enabled = 1 \
		GROUP BY gridimage_id

        sql_query_pre           = create temporary table tagtest (gridimage_id int unsigned primary key,newtags text) select gridimage_id,group_concat(if(prefix!='',concat(prefix,':',tag),tag) order by prefix = 'top' desc,tag SEPARATOR '?') as newtags from sph_delta_ids inner join gridimage_tag gt using (gridimage_id) inner join tag t using (tag_id) where gt.status = 2 and t.status = 1 group by gridimage_id order by null
        sql_query_pre           = update gridimage_search,tagtest set tags = newtags, upd_timestamp = upd_timestamp where gridimage_search.gridimage_id = tagtest.gridimage_id

        sql_query               = \
                SELECT gi.gridimage_id, UNIX_TIMESTAMP(gi.submitted) AS submitted, TO_DAYS(REPLACE(gi.imagetaken,'-00','-01')) AS takendays, gi.user_id, \
                gi.title, gi.comment, gi.imageclass, gi.realname, gi.grid_reference, \
                snippet_id, snippet, snippet_title, IF(tags!='',CONCAT('__TAG__ ',REPLACE(tags,'?',' __TAG__ '),' __TAG__'),'null') AS tags, \
                SUBSTRING(gi.grid_reference,1,LENGTH(gi.grid_reference)-4) AS myriad, \
                CONCAT(SUBSTRING(gi.grid_reference,1,LENGTH(gi.grid_reference)-3),SUBSTRING(gi.grid_reference,LENGTH(gi.grid_reference)-1,1)) AS hectad, \
                REPLACE(gi.imagetaken,'-','') AS takenday, REPLACE(substring(gi.imagetaken,1,7),'-','') AS takenmonth, substring(gi.imagetaken,1,4) AS takenyear, \
		MONTHNAME(gi.imagetaken) AS month, substring(gi.imagetaken,1,4) AS atakenyear, \
                RADIANS(gi.wgs84_lat) AS wgs84_lat,RADIANS(gi.wgs84_long) AS wgs84_long, \
                IF(gi.moderation_status='accepted','supplemental',gi.moderation_status) AS status, gi.ftf, gi.points, \
                CRC32(LOWER(gi.imageclass)) AS classcrc, LENGTH(gi.comment) AS clen, \
                (gi.reference_index * 10000000 + (viewpoint_northings DIV 1000) * 1000 + viewpoint_eastings DIV 1000) AS viewsquare, \
                gi.user_id AS auser_id, \
                coalesce(sequence,gi.gridimage_id+4000000) AS sequence, \
		UNIX_TIMESTAMP(REPLACE(gi.imagetaken,'-00','-01')) AS aimagetaken, \
		IF(gi.moderation_status = 'accepted' AND g2.nateastings>0 AND viewpoint_eastings>0 AND (g2.nateastings DIV 1000 != viewpoint_eastings DIV 1000 OR g2.natnorthings DIV 1000 != viewpoint_northings DIV 1000),'crossgrid','') AS grid, \
                conv(gi.grid_reference,36,10) as agridsquare, \
                conv(SUBSTRING(gi.grid_reference,1,LENGTH(gi.grid_reference)-4),36,10) AS amyriad, \
                conv(CONCAT(SUBSTRING(gi.grid_reference,1,LENGTH(gi.grid_reference)-3),SUBSTRING(gi.grid_reference,LENGTH(gi.grid_reference)-1,1)),36,10) AS ahectad, \
                (gi.reference_index * 10000000 + IF(g2.natgrlen+0 <= 3,((g2.nateastings DIV 100) mod 100) * 100 + ((g2.natnorthings DIV 100) mod 100),0)) AS scenti \
                FROM gridimage_search gi\
			INNER JOIN sph_delta_ids USING (gridimage_id) \
                        INNER JOIN gridimage g2 USING (gridimage_id) \
                        LEFT JOIN geograph_tmp.gridimage_snippet_text_delta gs USING (gridimage_id) \
			LEFT JOIN gridimage_sequence s ON (s.gridimage_id = gi.gridimage_id) \
                WHERE (gi.gridimage_id>=$start AND gi.gridimage_id<=$end)

	sql_query_killlist = \
		SELECT gridimage_id FROM sph_delta_ids UNION \
		SELECT gridimage_id FROM gridimage WHERE moderation_status = 'rejected' AND upd_timestamp > date_sub(now(),interval 2 day)

        sql_query_post           = DROP TABLE IF EXISTS geograph_tmp.gridimage_snippet_text_delta

        sql_query_range         = SELECT MIN(gridimage_id),MAX(gridimage_id) FROM sph_delta_ids
        sql_range_step          = 10000000

	sql_attr_multi		= uint bucket_id from query; SELECT gridimage_id,tag_id FROM tag INNER JOIN gridimage_tag USING (tag_id) INNER JOIN sph_delta_ids USING (gridimage_id) WHERE prefix = 'bucket'; 
}

#################

index gridimage
{
        source                  = gridimage
        path                    = /var/sphinx/gridimage
        docinfo                 = extern
        morphology              = none
        stopwords               =
        min_word_len            = 1
        charset_type            = sbcs

        min_prefix_len          = 0
        min_infix_len           = 0
	index_sp 		= 1
}
index gi_delta : gridimage
{
        source                  = gi_delta
        path                    = /var/sphinx/gi_delta
}

index gi_stemmed : gridimage
{
        source                  = gridimage
        path                    = /var/sphinx/gi_stemmed
        morphology              = stem_en
        index_exact_words       = 1
	wordforms 		= /var/sphinx/wordforms.txt
}
index gi_stemmed_delta : gi_delta
{
        source                  = gi_delta
        path                    = /var/sphinx/gi_stemmed_delta
        morphology              = stem_en
        index_exact_words       = 1
	wordforms 		= /var/sphinx/wordforms.txt
}

index gi_star
{
        source                  = gridimage
        path                    = /var/sphinx/gridimage_star
        docinfo                 = extern
        morphology              = none
        stopwords               =
        min_word_len            = 1
        charset_type            = sbcs
	enable_star		= 1
        min_prefix_len          = 0
        min_infix_len           = 3
	infix_fields 		= title,comment,imageclass
}



#############################################################################
## indexer settings
#############################################################################

indexer
{
	# memory limit
	#
	# may be specified in bytes (no postfix), kilobytes (mem_limit=1000K)
	# or megabytes (mem_limit=10M)
	#
	# will grow if set unacceptably low
	# will warn if set too low and potentially hurting the performance
	#
	# optional, default is 32M
	mem_limit		= 64M
}

#############################################################################
## searchd settings
#############################################################################

searchd
{
	# IP address on which search daemon will bind and accept
	# incoming network requests
	# listen = ( address ":" port | port | path ) [ ":" protocol ]

	listen = 3312
	listen = localhost:9306:mysql41

	# log file
	# searchd run info is logged here
	log			= /var/sphinx/log/searchd.log


	# query log file
	# all the search queries are logged here
	query_log		= /var/sphinx/log/query.log


	# client read timeout, seconds
	read_timeout		= 5

	workers=threads
	plugin_dir = /var/sphinx/plugins

        binlog_path = /var/sphinx/binlog

	# maximum amount of children to fork
	# useful to control server load
	max_children		= 300


	# a file which will contain searchd process ID
	# used for different external automation scripts
	# MUST be present
	pid_file		= /var/sphinx/run/searchd.pid


	# maximum amount of matches this daemon would ever retrieve
	# from each index and serve to client
	#
	# this parameter affects per-client memory and CPU usage
	# (16+ bytes per match) in match sorting phase; so blindly raising
	# it to 1 million is definitely NOT recommended
	#
	# starting from 0.9.7, it can be decreased on the fly through
	# the corresponding API call; increasing is prohibited to protect
	# against malicious and/or malformed requests
	#
	# default is 1000 (just like with Google)
	max_matches		= 1000


	compat_sphinxql_magics = 0 # the future is now
}

# --eof--


